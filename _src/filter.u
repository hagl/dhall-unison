use syntax.TextLiteral Chunks
use syntax.Constant
use syntax Expression
use syntax.Expression Lambda Forall Let Variable If Merge ToMap EmptyList NonEmptyList Annotation Operator Application Field ProjectByLabels ProjectByType Completion Assert With DoubleLiteral NaturalLiteral IntegerLiteral TextLiteral RecordType RecordLiteral UnionType DateLiteral TimeLiteral TimeZoneLiteral Operator Builtin Constant

syntax.filterExpressions : (Expression -> Boolean) -> Expression -> [Expression]
syntax.filterExpressions p expression =
  go : Expression -> [Expression]
  go ex =
    f = List.filter p
    (if p ex then [ex]  else [])  ++
    match ex with
      Lambda x A b -> f [A, b]
      Forall x A B -> f [A, B]
      Let x t a b-> f (Optional.toList t ++ [a, b])
      If t l r -> f [t, l, r]
      Merge t u ot -> f (Optional.toList ot ++ [t, u])
      ToMap t ot -> f (Optional.toList ot ++ [t])
      EmptyList T -> f [T]
      NonEmptyList ts -> f (Nonempty.toList ts)
      Annotation t T -> f [t, T]
      Operator l op r -> f [l, r]
      Application a b -> f [a, b]
      Field t y -> f [t]
      ProjectByLabels t xs -> f [t]
      ProjectByType t T -> f [t, T]
      Completion T r -> f [T, r]
      Assert T -> f [T]
      With e ks v -> f [e, v]
      TextLiteral (Chunks xys z) -> f (List.map Tuple.at2 xys)
      RecordType ks -> f (List.map Tuple.at2 ks)
      RecordLiteral ks -> f (List.map Tuple.at2 ks)
      UnionType ks -> f (List.filterMap Tuple.at2 ks)
      DhallSome a -> f [a]
      _ -> []
  go expression
