use .trunk.syntax

alpha_normalization.alphaNormalize: Expression -> Expression 
alpha_normalization.alphaNormalize = cases
  Lambda "_" A0 b0 -> Lambda "_" (alphaNormalize A0) (alphaNormalize b0)
  Lambda x A0 b0 -> 
    b1 = shift +1 "_" zero b0
    b2 = substitute b1 x zero (Variable "_" zero)
    b3 = shift -1 x zero b2
    Lambda "_" (alphaNormalize A0) (alphaNormalize (b3))
  Forall "_" A0 B0 -> Forall "_" (alphaNormalize A0) (alphaNormalize B0)
  Forall x A0 B0 ->
    B1 = shift +1 "_" zero B0
    B2 = substitute B1 x zero (Variable "_" zero)
    B3 = shift -1 x zero B2
    Forall "_" (alphaNormalize A0) (alphaNormalize B3)
  Let "_" t a0 b0 -> Let "_" (Optional.map alphaNormalize t) (alphaNormalize a0) (alphaNormalize b0)
  Let x t a0 b0 ->
    b1 = shift +1 "_" zero b0
    b2 = substitute b1 x zero (Variable "_" zero)
    b3 = shift -1 x zero b2
    Let "_" (Optional.map alphaNormalize t) (alphaNormalize a0) (alphaNormalize b3)
  Variable x n -> Variable x n
  If t0 l0 r0 -> If (alphaNormalize t0) (alphaNormalize l0) (alphaNormalize r0)
  Merge t0 u0 t -> Merge (alphaNormalize t0) (alphaNormalize u0) (Optional.map alphaNormalize t)
  ToMap t0 t -> ToMap (alphaNormalize t0)(Optional.map alphaNormalize t)
  EmptyList T0 -> EmptyList (alphaNormalize T0)
  NonEmptyList ts0 -> NonEmptyList (Nonempty.map alphaNormalize ts0)
  Annotation t0 T0 -> Annotation (alphaNormalize t0) (alphaNormalize T0)
  Expression.Operator l0 op r0 -> Expression.Operator (alphaNormalize l0) op (alphaNormalize r0)
  Application f0 a0 -> Application (alphaNormalize f0) (alphaNormalize a0)
  Field t0 y -> Field (alphaNormalize t0) y
  ProjectByLabels t0 xs -> ProjectByLabels (alphaNormalize t0) xs
  ProjectByType t0 T0 -> ProjectByType (alphaNormalize t0) (alphaNormalize T0)
  Completion T0 r0 -> Completion (alphaNormalize T0) (alphaNormalize r0)
  Assert T0 -> Assert (alphaNormalize T0)
  With e0 ks v0 -> With (alphaNormalize e0) ks (alphaNormalize v0)
  DoubleLiteral d -> DoubleLiteral d
  NaturalLiteral n -> NaturalLiteral n
  IntegerLiteral n -> IntegerLiteral n
  Expression.TextLiteral (Chunks xys0 z) -> Expression.TextLiteral (Chunks (List.map (cases (s, t0) -> (s, alphaNormalize t0)) xys0) z)
  RecordType ks0 -> RecordType (List.map (cases (k, t_T0) -> (k, alphaNormalize t_T0)) ks0)
  RecordLiteral ks0 -> RecordLiteral (List.map (cases (k, t_T0) -> (k, alphaNormalize t_T0)) ks0)
  UnionType ks0 -> UnionType (List.map (cases (k, t) -> (k, Optional.map alphaNormalize t)) ks0)
  Expression.Some a0 -> Expression.Some (alphaNormalize a0)
  Expression.Builtin b -> Expression.Builtin b
  Expression.Constant c -> Expression.Constant c

use test

test> alpha_normalization.alphaNormalize.tests.ex1 = check(alphaNormalize(
  Lambda "a" (Expression.Constant Constant.Type) (
    Lambda "b" (Expression.Constant Constant.Type) (
      Lambda "x" (Variable "a" zero) (
        Lambda "y" (Variable "b" zero) (
          Variable "x" zero)))))
  ===
  Lambda "_" (Expression.Constant Constant.Type) (
    Lambda "_" (Expression.Constant Constant.Type) (
      Lambda "_" (Variable "_" one) (
        Lambda "_" (Variable "_" one) (
          Variable "_" one)))))
