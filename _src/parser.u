use lib.uniparsec Parser ErrorFancy
use lib.uniparsec.Parser <* string oneOf
use lib.uniparsec.Parser.ascii char
-- use parser.util string
use syntax TextLiteral
use syntax.TextLiteral Chunks
use syntax.Constant
use syntax Expression
use syntax addTextToTextLiteral
use syntax.Expression Lambda Forall Let Variable If Merge ToMap EmptyList NonEmptyList Annotation Operator Application Field ProjectByLabels ProjectByType Completion Assert With DoubleLiteral NaturalLiteral IntegerLiteral TextLiteral RecordType RecordLiteral UnionType DateLiteral TimeLiteral TimeZoneLiteral Operator Builtin Constant DhallSome
use syntax.ImportMode Code RawText Location
use syntax ImportType
use syntax File
use syntax.File File
use support Date Time TimeZone Integer
use syntax.Scheme HTTP HTTPS
use syntax.ImportType Path Missing Remote Env

use Optional

-- parser.util.string : Text -> Parser e Char Text
-- parser.util.string t =
--   x : Parser e Char [Char]
--   x = util.tokens (a b -> a === b) (toCharList t)
--   x $> fromCharList

(parser.combinators.>>=) : Parser e t a -> (a -> Parser e t b) -> Parser e t b
(parser.combinators.>>=) x y = Parser.flatMap y x

(parser.combinators.+:>) : Parser e Char Char -> Parser e Char Text -> Parser e Char Text
(parser.combinators.+:>) p1 p2 = Parser.flatMap (c -> p2 $> (t -> (Char.toText c) ++ t)) p1

(parser.combinators.++>) : Parser e Char Text -> Parser e Char Text -> Parser e Char Text
(parser.combinators.++>) p1 p2 = Parser.flatMap (c -> p2 $> (t -> c ++ t)) p1

parser.combinators.sepBy1 : Parser e t b -> Parser e t a -> Parser e t (List.Nonempty b)
parser.combinators.sepBy1 pa ps =
  go a =
    Parser.map (as -> Nonempty a as) (many0 (ps *> pa))
  Parser.flatMap go pa

parser.combinators.takeWhile : (Char -> Boolean) -> Parser e Char Text
parser.combinators.takeWhile predicate = Parser.many0 (satisfy predicate) $> Text.fromCharList

parser.combinators.takeWhile1 : (Char -> Boolean) -> Parser e Char Text
parser.combinators.takeWhile1 predicate = Parser.many1 (satisfy predicate) $> Text.fromCharList

parser.combinators.peek : Parser e Char (Optional Char)
parser.combinators.peek =
  parse: '{Tokens e Char} () ->{Throw (Error e Char)} (Optional Char, '{Tokens e Char} ())
  parse input = handle !input with cases
    {Tokens.emit loc tok -> rest} -> (Optional.Some tok, input)
    { _ } -> (None, input)
  Parser.Parser parse

parser.getLocation : Parser e t Location
parser.getLocation =
  parse : '{Tokens e t} () ->{Throw (Error e t)} (Location, '{Tokens e t} ())
  parse input =
      handle !input
    with
      cases
        {Tokens.emit loc tok -> _} -> (loc, input)
        { _ }                         -> (unknown, input)
  Parser.Parser parse


parser.combinators.failMessage : Text -> Parser e Char a
parser.combinators.failMessage error = getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail error))))

parser.tokens.eof: Parser e Char ()
parser.tokens.eof =
  parse : '{Tokens e Char} () ->{Throw (Error e Char)} ((), '{Tokens e t} ())
  parse input =
    h = cases
      {Tokens.emit loc t -> resume} -> throw (TrivialError loc (Some (Tokens [t])) (Set.singleton EndOfInput))
      {Tokens.fail e -> _}          -> throw e
      { _ } -> ((), '())
    handle !input with h
  Parser.Parser parse

parser.tokens.eol : Parser e Char Text
parser.tokens.eol = Parser.label (Parser.or
    (string "\n")
    (string "\r\n")) "newline"

parser.tokens.lambda : Parser e Char ()
parser.tokens.lambda = Parser.or (eq ?λ) (eq ?\\) $> '()

parser.tokens._forall : Parser e Char ()
parser.tokens._forall = Parser.or (eq ?∀ $> '()) ((string "forall") $> '())

parser.tokens.importAlt = eq ?? $> '()
parser.tokens._or = string "||" $> '()
parser.tokens.plus = char ?+
parser.tokens.minus = char ?-
parser.tokens.textAppend = string "++" $> '()
parser.tokens.listAppend = eq ?# $> '()
parser.tokens._and = string "&&" $> '()
parser.tokens.combine = or (eq ?∧ $> '()) (string "/\\" $> '())
parser.tokens.prefer = or (eq ?⫽ $> '()) (string "//" $> '())
parser.tokens.combineTypes = or (eq ?⩓ $> '()) (string "//\\\\" $> '())
parser.tokens.times = eq ?* $> '()
parser.tokens.dot = eq ?. $> '()
parser.tokens.comma = eq ?, $> '()
parser.tokens.openParen = char ?(
parser.tokens.closeParen = char ?)
parser.tokens.openBrace = char ?{
parser.tokens.closeBrace = char ?}
parser.tokens.openAngle = char ?<
parser.tokens.closeAngle = char ?>
parser.tokens.openBracket = char ?[
parser.tokens.closeBracket = char ?]
parser.tokens.colon = char ?:
parser.tokens.bar = char ?|
parser.tokens.doubleColon = string "::" $> '()
parser.tokens.at = char ?@
parser.tokens._with = string "with" $> '()

parser.tokens.builtin : Text -> Parser e Char ()
parser.tokens.builtin text = Parser.label (string text $> '())"builtin"

parser.tokens.doubleEqual = (string "==") *> peek >>= cases
    (Optional.Some ?=) -> Parser.fail (TrivialError unknown None (Set.singleton (Label "==")))
    _ -> Parser.const ()

test> parser.tokens.doubleEqual.tests.ex1 = check(parseText parser.tokens.doubleEqual "==" === (Right ()))
test> parser.tokens.doubleEqual.tests.ex2 = check(parseText parser.tokens.doubleEqual "===" |> Either.isLeft)
test> parser.tokens.doubleEqual.tests.ex3 = check(parseText (parser.tokens.doubleEqual <* digit) "==1" === (Right ()))

parser.tokens.notEqual = string "!=" $> '()
parser.tokens.equal = char ?=

parser.tokens.arrow : Parser e Char ()
parser.tokens.arrow = Parser.or (eq ?→ $> '()) ((string "->") $> '())

parser.tokens.equivalent : Parser e Char ()
parser.tokens.equivalent = or ((eq ?≡)  $> '()) ((string "===")  $> '())

parser.tokens.hexChar: Parser e Char Char
parser.tokens.hexChar = Parser.token (c -> if Char.ascii.isHexDigit c then Some c else None)

parser.backtickLabel : Parser e Char Text
parser.backtickLabel =
  predicate c = (Char.inRange ?\s ?_ c) || (Char.inRange ?a ?~ c)
  parser = (char ?`) *> (Parser.many0 (satisfy predicate) $> Text.fromCharList) <* (char ?`)
  Parser.label parser "label in backticks"

parser.simpleLabel : Boolean -> Parser e Char Text
parser.simpleLabel allowReserved =
    restricted = if allowReserved then reservedKeywords else reservedIdentifiers
    (satisfy headCharacter
      >>= (h -> Parser.many0 (satisfy tailCharacter) $> (t -> Text.fromCharList (h +: t))))
      >>= (label -> if (Set.contains label restricted)
        then getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("'" ++ label ++ "' is a reserved word")))))
        else Parser.const label)

parser.label : Parser e Char Text
parser.label = Parser.label (Parser.or backtickLabel (simpleLabel false)) "label"

parser.anyLabel : Parser e Char Text
parser.anyLabel = Parser.label (Parser.or backtickLabel (simpleLabel true)) "any label"

parser.nonreservedLabel : Parser e Char Text
parser.nonreservedLabel = label

parser.anyLabelOrSome : Parser e Char Text
parser.anyLabelOrSome = or anyLabel (Parser.label (string "Some") "Some")

parser.labels : Parser e Char [Text]
parser.labels =
  emptyLabels = (optional (comma *> whitespace)) *> closeBrace $> '[]

  nonEmptyLabels =
    (optional (comma *> whitespace)) *>
      (sepBy1 anyLabelOrSome (whitespace *> comma *> whitespace)) <*
      (whitespace *> optional (comma *> whitespace) *> closeBrace) $> Nonempty.toList

  openBrace *> whitespace *> (or nonEmptyLabels emptyLabels)

use base.Char ascii
parser.headCharacter : Char -> Boolean
parser.headCharacter c = isLetter c || (c == ?_)

parser.tailCharacter : Char -> Boolean
parser.tailCharacter c = isAlphaNum c || (c == ?_) || (c == ?-) || (c == ?/)

parser.whitespace : Parser e Char ()
parser.whitespace = (many0 whitespaceChunk) $> '()

parser.nonemptyWhitespace : Parser e Char ()
parser.nonemptyWhitespace = (many1 whitespaceChunk) $> '()

parser.whitespaceChunk : Parser e Char ()
parser.whitespaceChunk =
  predicate c = if c == ?\s || (c == ?\t) || (c == ?\n) then Some () else None
  Parser.label (oneOf
    [ many1 (Tokens.token predicate) $> '()
    , Parser.label (string "\r\n") "newline" $> '()
    , lineComment $> '()
    , blockComment $> '()
    ] $> '()) "whitespace"

parser.charInRange : Nat -> Nat -> Parser e Char Char
parser.charInRange from to =
  predicate = match (Char.fromNat from, Char.fromNat to) with
    (Some f, Some t) -> (c -> if Char.inRange f t c then Some c else None)
    _ -> (c -> None)
  Tokens.token predicate

parser.lineCommentPrefix : Parser e Char Text
parser.lineCommentPrefix =
    predicate = match (Char.fromNat 0x0010FFFF) with
      Some limit -> (c -> if (Char.inRange ?\s limit c || (c == ?\t)) then Some c else None)
      _ -> (c -> None)
    (string "--") Parser.*> (Parser.many0 (Tokens.token predicate)) $> (comment -> "--" ++ (Text.fromCharList comment))

parser.lineComment : Parser e Char Text
parser.lineComment = (lineCommentPrefix <* eol)

parser.blockComment : Parser e Char Text
parser.blockComment = blockCommentLevel ()

parser.blockCommentLevel : 'Parser e Char Text
parser.blockCommentLevel = '(string "{-" >>= (s -> blockCommentContinue ()) $> (c -> "{-" ++ c ++ "-}"))

parser.blockCommentChunk : 'Parser e Char Text
parser.blockCommentChunk _ =
  match (Char.fromNat 0x0010FFFF) with
    Some limit ->
      characters = Parser.many1 (
        Tokens.token (c -> if ((Char.inRange ?\s limit c && (not (c == ?-)) && (not (c == ?{))) || (c == ?\n) || (c == ?\t) ) then Some c else None)    ) $> Text.fromCharList
      character =Tokens.token (c -> if Char.inRange ?\s limit c || (c == ?\n) || (c == ?\t) then Some c else None) $> Char.toText
      oneOf
        [ (blockCommentLevel ())
        , characters
        , character
        , eol
        ]
    _ -> Parser.fail (TrivialError unknown None (Set.singleton (Label "Can't convert 0x0010FFFF to char")))

parser.blockCommentContinue : 'Parser e Char Text
parser.blockCommentContinue _ =
  endOfComment = string "-}" $> (_ -> "")
  continue = !blockCommentChunk >>= (chunk -> !blockCommentContinue $> (cont -> chunk ++ cont))
  or endOfComment continue

parser.shebang : Parser e Char Text
parser.shebang =
  match (Char.fromNat 0x10FFFF) with
    Some limit ->
      predicate c = Char.inRange ?\s limit c || (c == ?\t)
      string "#!" *> (takeWhile predicate) <* eol
    _ -> Parser.fail (TrivialError unknown None (Set.singleton (Label "Can't convert 0x10FFFF to char")))

parser.parseText : Parser Void Char r -> Text -> Either Text r
parser.parseText parser text =
  Either.mapLeft printError (Parser.run (parser <* eof) (Tokens.fromText text))

parser.exponent : Parser e Char Text
parser.exponent =
  (eq ?e)
    +:> (Parser.optional((Parser.or plus minus) $> Char.toText) $> Optional.getOrElse "")
    ++> (many1 digit $> Text.fromCharList)

parser.numericDoubleLiteral : Parser e Char Text
parser.numericDoubleLiteral =
  Parser.optional((Parser.or (plus  $> (const "")) (minus $> Char.toText))) $> Optional.getOrElse ""
    ++> (many1 digit $> Text.fromCharList)
    ++> (or
      ((eq ?.) +:> (many1 digit $> Text.fromCharList)
        ++> ((Parser.optional exponent) $> (Optional.getOrElse "")))
      exponent)

parser.doubleLiteral : Parser e Char Float
parser.doubleLiteral =
  err : Text -> Text -> Parser e Char Float
  err text reason = getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("'" ++ text ++ "' cannot be parsed as float. " ++ reason)))))
  textToFloat : Text -> Parser e Char Float
  textToFloat s = match Float.fromText s with
    Optional.Some f -> match Float.toText f with
      "NaN" -> err s ""
      "Infinity" -> err s " The number is too big"
      "-Infinity" -> err s " The number is too small"
      _ -> Parser.const f
    None -> err s ""
  -- Parser.flatMap textToFloat (oneOf [
  oneOf [
      string "-Infinity" $> 'support.negInfinity
    , string "Infinity"  $> 'support.infinity
    , string "NaN" $> 'support.nan
    , numericDoubleLiteral >>= textToFloat
  ]

test> parser.doubleLiteral.tests.ex1 = check (parseText parser.doubleLiteral "123.456789e-100" === Right 123.456789e-100)
test> parser.doubleLiteral.tests.ex2 = check (parseText parser.doubleLiteral "+123.456789e+100" === Right 123.456789e+100)
test> parser.doubleLiteral.tests.ex3 = check (parseText parser.doubleLiteral "Infinity" |> Either.mapRight Float.toText === Right "Infinity")
test> parser.doubleLiteral.tests.ex4 = check (parseText parser.doubleLiteral "-Infinity" |> Either.mapRight Float.toText === Right "-Infinity")
test> parser.doubleLiteral.tests.ex5 = check (parseText parser.doubleLiteral "NaN" |> Either.mapRight Float.toText === Right "NaN")

parser.naturalLiteral : Parser e Char Natural
parser.naturalLiteral = oneOf [
    (string "0x" *> (many1 hexChar) $> Text.fromCharList
      >>= (s -> match (Natural.parse 16 s) with
        None -> (getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("'" ++ s ++ "' cannot be parsed as hex literal"))))))
        Optional.Some n -> Parser.const n))
  , (charInRange (Char.toNat ?1) (Char.toNat ?9) +:> (many0 (Parser.token (c -> if Char.ascii.isDigit c then Some c else None)) $> Text.fromCharList)
      >>= (s -> match (Natural.parse 10 s) with
        None -> (getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("'" ++ s ++ "' cannot be parsed as natural literal"))))))
        Optional.Some n -> Parser.const n))
  , string "0" $> (const zero)
  ]

test> parser.naturalLiteral.test.ex1 = check (parseText parser.naturalLiteral "0x0" === Right zero)
test> parser.naturalLiteral.test.ex2 = check (parseText parser.naturalLiteral "12345" === Right (Natural.fromNat 12345))
test> parser.naturalLiteral.test.ex3 = check (parseText parser.naturalLiteral "12345678901234567890" |> Either.right === Natural.parse 10 "12345678901234567890" )
test> parser.naturalLiteral.test.ex4= check (parseText parser.naturalLiteral "+1" |> Either.isLeft)
test> parser.naturalLiteral.test.ex5= check (parseText parser.naturalLiteral "-1" |> Either.isLeft)
test> parser.naturalLiteral.test.ex6= check (parseText (parser.naturalLiteral <* eof) "1F3A" |> Either.isLeft)
test> parser.naturalLiteral.test.ex7= check (parseText (parser.naturalLiteral <* eof) "00" |> Either.isLeft)
test> parser.naturalLiteral.test.ex8= check (parseText parser.naturalLiteral "0" === Right zero)

parser.integerLiteral : Parser e Char Integer
parser.integerLiteral = (Parser.or
  (minus *> naturalLiteral $> Integer.negative)
  (plus *> naturalLiteral $> Integer.positive)
  )

test> parser.integerLiteral.test.ex1 = check (parseText parser.integerLiteral "-0x0" === Right (Integer.positive zero))
test> parser.integerLiteral.test.ex2 = check (parseText parser.integerLiteral "-1" === Right (Integer.negative one))

parser.validUnicodeCodePoint: Nat -> Boolean
parser.validUnicodeCodePoint n =
  ((0x0 <= n) && (n <= 0xD7FF)) ||
    ((0xE000 <= n) && (n <= 0xFFFD)) ||
    ((0x10000 <= n) && (n <= 0x1FFFD)) ||
    ((0x20000 <= n) && (n <= 0x2FFFD)) ||
    ((0x30000 <= n) && (n <= 0x3FFFD)) ||
    ((0x40000 <= n) && (n <= 0x4FFFD)) ||
    ((0x50000 <= n) && (n <= 0x5FFFD)) ||
    ((0x60000 <= n) && (n <= 0x6FFFD)) ||
    ((0x70000 <= n) && (n <= 0x7FFFD)) ||
    ((0x80000 <= n) && (n <= 0x8FFFD)) ||
    ((0x90000 <= n) && (n <= 0x9FFFD)) ||
    ((0xA0000 <= n) && (n <= 0xAFFFD)) ||
    ((0xB0000 <= n) && (n <= 0xBFFFD)) ||
    ((0xC0000 <= n) && (n <= 0xCFFFD)) ||
    ((0xD0000 <= n) && (n <= 0xDFFFD)) ||
    ((0xE0000 <= n) && (n <= 0xEFFFD)) ||
    ((0xF0000 <= n) && (n <= 0xFFFFD)) ||
    ((0x100000 <= n) && (n <= 0x10FFFD))

parser.validNonAscii : Parser e Char Char
parser.validNonAscii =
  predicate c =
    n = Char.toNat c
    use .base.Nat <=
    if ((0x80 <= n) && validUnicodeCodePoint n)
    then Some c
    else None
  Tokens.token predicate

parser.singleQuoteChar : Parser e Char Text
parser.singleQuoteChar = oneOf [
    charInRange 0x20 0x7F $> Char.toText
  , validNonAscii $> Char.toText
  , eq ?\t $> Char.toText
  , eol
  ]

parser.doubleQuoteChar : Parser e Char Char
parser.doubleQuoteChar = oneOf [
    charInRange 0x20 0x21
  , charInRange 0x23 0x5b
  , charInRange 0x5d 0x7f
  , validNonAscii
  ]

parser.validCodePoint : Text -> Parser e Char Char
parser.validCodePoint s = match Optional.flatMap Natural.toMaybeNat (Natural.parse 16 s) with
  Optional.Some n -> if (validUnicodeCodePoint n)
    then match (Char.fromNat n) with
      Some c -> Parser.const c
      _ -> (getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("'" ++ s ++ "' can't be converted to char"))))))
    else (getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("'" ++ s ++ "' is not a valid unicode codepoint"))))))
  None -> (getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("'" ++ s ++ "' cannot be parsed as unicode escape"))))))

parser.unbracedEscape : Parser e Char Char
parser.unbracedEscape = (hexChar ^ hexChar ^ hexChar ^ hexChar) >>= cases (((a ,b) ,c), d) ->
    validCodePoint (Text.fromCharList [a, b, c, d])

parser.bracedEscape : Parser e Char Char
parser.bracedEscape = (many1 hexChar) >>= cases chars ->
    validCodePoint (Text.fromCharList chars)

parser.unicodeEscape : Parser e Char Char
parser.unicodeEscape =
  or
    unbracedEscape
    (eq ?{ *> bracedEscape <* (eq ?}))

parser.doubleQuoteEscaped : Parser e Char Char
parser.doubleQuoteEscaped =
  or
    (Tokens.token cases
      ?" -> Some ?"
      ?$ -> Some ?$
      ?\\ -> Some ?\\
      ?/ -> Some ?/
      ?b -> Some ?\b
      ?f -> Some ?\f
      ?r -> Some ?\r
      ?n -> Some ?\n
      ?t -> Some ?\t
      _ -> None)
    (eq ?u *> unicodeEscape)

-- | 'ApplicationExprInfo' distinguishes certain subtypes of application
-- expressions.
unique type parser.ApplicationExprInfo
    = NakedMergeOrSomeOrToMap
    -- ^ @merge x y@, @Some x@ or @toMap x@, unparenthesized.
    | ImportExpr
    -- ^ An import expression.
    | ApplicationExpr
    -- ^ Any other application expression.

parser.alternative0 : Parser e Char Expression -> (Parser e Char Expression)
parser.alternative0 dExpression =
  (lambda *> whitespace *> openParen *> whitespace *> label <* whitespace <* (char ?:) <* nonemptyWhitespace) ^
  (dExpression <* whitespace <* closeParen <* whitespace <* arrow <* whitespace) ^
  dExpression $> cases
    ((a, b), c) -> Lambda a b c

parser.alternative1 : Parser e Char Expression -> (Parser e Char Expression)
parser.alternative1 dExpression =
  (string "if" *> nonemptyWhitespace *> dExpression <* whitespace) ^
  (string "then" *> nonemptyWhitespace *> dExpression <* whitespace) ^
  (string "else" *> nonemptyWhitespace *> dExpression) $> cases
    ((a, b), c) -> If a b c


parser.alternative2 : Parser e Char Expression -> (Parser e Char Expression)
parser.alternative2 dExpression =
  letBinding : Parser e Char ((Text, Optional Expression), Expression)
  letBinding =
    (string "let" *> nonemptyWhitespace *> nonreservedLabel <* whitespace) ^
    (Parser.optional (string ":" *> nonemptyWhitespace *> dExpression <* whitespace)) ^
    (string "=" *> whitespace *> dExpression <* whitespace)
  ((many1 letBinding) <* string "in" <* nonemptyWhitespace) ^ dExpression $> cases
    (ls, ex) ->
      List.foldRight (cases ((l, mT), e) -> ex -> Let l mT e ex) ex ls

-- ; "forall (x : a) -> b"
-- / forall whsp "(" whsp nonreserved-label whsp ":" whsp1 expression whsp ")" whsp arrow whsp expression

parser.alternative3 : Parser e Char Expression -> (Parser e Char Expression)
parser.alternative3 dExpression =
  (_forall *> whitespace *> openParen *>  whitespace *> nonreservedLabel <* whitespace) ^
  (string ":" *> nonemptyWhitespace *> dExpression <* whitespace <* closeParen <* whitespace) ^
  (arrow *> whitespace *> dExpression) $> cases
    ((a, b), c) -> Forall a b c

-- / assert whsp ":" whsp1 expression
parser.alternative4 : Parser e Char Expression -> (Parser e Char Expression)
parser.alternative4 dExpression =
  string "assert" *> whitespace *> (eq ?:) *> nonemptyWhitespace *> dExpression $> Assert


parser.operatorParsers : [Parser e Char (Expression -> Expression -> Expression)]
parser.operatorParsers =
    [ equivalent <* whitespace $> '(a b -> Operator a Equivalent b)
    , importAlt <* nonemptyWhitespace $> '(a b -> Operator a Alternative b)
    , _or <* whitespace $> '(a b -> Operator a Or b)
    , plus <* nonemptyWhitespace $> '(a b -> Operator a Plus b)
    , textAppend <* whitespace $> '(a b -> Operator a TextAppend b)
    , listAppend <* whitespace $> '(a b -> Operator a ListAppend b)
    , _and <* whitespace $> '(a b -> Operator a And b)
    , combine <* whitespace $> '(a b -> Operator a CombineRecordTerms b)
    , prefer <* whitespace $> '(a b -> Operator a Prefer b)
    , combineTypes <* whitespace $> '(a b -> Operator a CombineRecordTypes b)
    , times <* whitespace $> '(a b -> Operator a Times b)
    , doubleEqual <* whitespace $> '(a b -> Operator a Equal b)
    , notEqual <* whitespace $> '(a b -> Operator a NotEqual b)
    ]

-- parser.hash : Parser e Char syntax.SHA256Digest
-- parser.hash = ((string "sha256:") *> (many1 (hexChar ^ hexChar))) $> List.map (cases (a,b) -> Optional.flatMap Natural.toMaybeNat (Natural.parse 16 (fromCharList [a, b])))>>= (
--       nats ->
--         if (List.all Optional.isSome nats) && (List.size nats == 32)
--         then (match catch '(Bytes.fromList (List.somes nats)) with
--           Right bs -> Parser.const (syntax.SHA256Digest.SHA256Digest bs)
--           _ -> (getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("Can't convert to hex digits")))))))
--         else (getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("Hash must consist of 64 hex digits")))))))

parser.hash : Parser e Char syntax.SHA256Digest
parser.hash = ((string "sha256:") *> (many1 (hexChar ^ hexChar))) $> List.map (cases (a,b) -> Optional.flatMap Natural.toMaybeNat (Natural.parse 16 (fromCharList [a, b])))>>= (
      nats -> if (List.all Optional.isSome nats) && (List.size nats == 32) then Parser.const (syntax.SHA256Digest.SHA256Digest (Bytes.fromList.impl (List.somes nats)))
        else (getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("Hash must consist of 64 hex digits")))))))

-- ; Printable characters other than " ()[]{}<>/\,"
-- ;
-- ; Excluding those characters ensures that paths don't have to end with trailing
-- ; whitespace most of the time
parser.pathCharacter : Parser e Char Char
parser.pathCharacter =
  oneOf [
      charInRange 0x21 0x21
    , charInRange 0x24 0x27
    , charInRange 0x2A 0x2B
    , charInRange 0x2D 0x2E
    , charInRange 0x30 0x3B
    , charInRange 0x3D 0x3D
    , charInRange 0x40 0x5A
    , charInRange 0x5E 0x7A
    , charInRange 0x7C 0x7C
    , charInRange 0x7E 0x7E
    ]

parser.quotedPathCharacter : Parser e Char Char
parser.quotedPathCharacter =
    oneOf [
        charInRange 0x20 0x21
      , charInRange 0x23 0x2E
      , charInRange 0x30 0x7F
      , validNonAscii
      ]


parser.unquotedPathComponent : Parser e Char Text
parser.unquotedPathComponent = (many1 parser.pathCharacter) $> Text.fromCharList

parser.quotedPathComponent : Parser e Char Text
parser.quotedPathComponent = (many1 parser.quotedPathCharacter) $> Text.fromCharList

parser.pathComponent : Parser e Char Text
parser.pathComponent = (char ?/) *> (or unquotedPathComponent ((char ?" *> quotedPathComponent <* (char ?"))))

parser.path : Parser e Char syntax.File
parser.path = (many1 pathComponent) >>= (l -> match List.mayNonempty l with
  Some nel -> Parser.const (syntax.File.File (List.reverse (Nonempty.init nel)) (Nonempty.last nel))
  None  -> (getLocation >>= (loc -> Parser.fail (FancyError loc (Set.singleton (ErrorFail ("Path must have at lease one component")))))))

parser.parentPath : Parser e Char ImportType
parser.parentPath = (string "..") *> path $> (f -> Path Parent f)
parser.herePath : Parser e Char ImportType
parser.herePath = (string ".") *> path $> (f -> Path Here f)
parser.homePath : Parser e Char ImportType
parser.homePath = (string "~") *> path $> (f -> Path Home f)
parser.absolutePath : Parser e Char ImportType
parser.absolutePath = path $> (f -> Path Absolute f)

parser.local = Parser.oneOf [
  parentPath,
  herePath,
  homePath,
  absolutePath
]

parser.bashEnvironmentVariable : Parser e Char Text
parser.bashEnvironmentVariable = (or (char ?_ ) ascii.letter) ^ (many0  (or (char ?_ ) ascii.alphanum)) $> cases (c, cl) -> Text.fromCharList (c +: cl)

parser.posixEnvironmentVariable : Parser e Char Text
parser.posixEnvironmentVariable = (many1 parser.posixEnvironmentChar) $> (cl -> Text.fromCharList cl)

parser.posixEnvironmentChar : Parser e Char Char
parser.posixEnvironmentChar = oneOf [
  string "\\\"" $> '?",
  string "\\\\" $> '?\\,
  string "\\a" $> '?\a,
  string "\\b" $> '?\b,
  string "\\f" $> '?\f,
  string "\\n" $> '?\n,
  string "\\r" $> '?\r,
  string "\\t" $> '?\t,
  string "\\v" $> '?\v,
  charInRange 0x20 0x21,
  charInRange 0x23 0x3c,
  charInRange 0x3e 0x5b,
  charInRange 0x5d 0x7e
]

parser.env : Parser e Char syntax.ImportType
parser.env = string "env:" *> (or parser.bashEnvironmentVariable ((char ?") *> parser.posixEnvironmentVariable <* (char ?"))) $> Env


parser.scheme : Parser e Char syntax.Scheme
parser.scheme = (string "http") *> (optional (char ?s)) $> (Optional.fold 'HTTP 'HTTPS)

parser.authority : Parser e Char Text
parser.authority = (optional (userinfo <* (char ?@))) ^ host ^ (optional ((char ?:) *> port)) $> cases ((u, h), p) -> (Optional.fold (_ -> "") (u -> u ++ "@") u)  ++ h ++ (Optional.fold (_ -> "") ((++) ":") p)

parser.userinfoChars : Parser e Char Text
parser.userinfoChars = Parser.map Char.toText (oneOf [
  unreserved,
  subDelims,
  (char ?:)
])

parser.userinfo : Parser e Char Text
parser.userinfo = Parser.map (Text.join "") (many1 (oneOf [
  parser.userinfoChars,
  pctEncoded
]))
-- userinfo = *( unreserved / pct-encoded / sub-delims / ":" )

parser.decOctet : Parser e Char Text
parser.decOctet = oneOf [
  string "25" *> (charInRange 0x30 0x35) $> (c -> "25" ++ (Char.toText c)),
  string "2" *> (charInRange 0x30 0x34) ^ ascii.digit $> cases (c, d) -> Text.fromCharList [?2, c, d],
  string "1" *> ascii.digit ^ ascii.digit $> cases (c, d) -> Text.fromCharList [?1, c, d],
  charInRange 0x31 0x39 ^ ascii.digit $> cases (c, d) -> Text.fromCharList [c, d],
  ascii.digit $> Char.toText
]

parser.IPv4address : Parser e Char Text
parser.IPv4address = decOctet ^ ((char ?.) *> decOctet) ^ ((char ?.) *> decOctet) ^ ((char ?.) *> decOctet) $> cases
  (((a,b), c), d) -> Text.join "." [a,b,c,d]


parser.IPvFuture = (char ?v) *> (many1 hexChar) ^ ((char ?.) *> (many1 (oneOf [unreserved, subDelims, (char ?:)))) $> cases
  (v, w) -> Text.fromCharList (?. +: v ++ (?. +: w))

parser.h16 : Parser e Char Text
-- parser.h16 = hexChar ^ hexChar ^ hexChar ^ hexChar $> cases (((a, b), c), d) -> Text.fromCharList [a, b, c, d]
parser.h16 = repeatMinMax 1 4 hexChar $> Text.fromCharList

parser.ls32 : Parser e Char Text
parser.ls32 = oneOf [
  parser.h16 ^ ((char ?:) *> parser.h16) $> cases (a, b) -> a ++ ":" ++ b,
  parser.IPv4address
]

parser.utils.repeat : Nat -> Parser e Char a -> Parser e Char [a]
parser.utils.repeat n p =
  go = cases
    0 -> Parser.const []
    n -> p >>= ( x -> Parser.map ((List.+:) x) (go (n - 1)))
  go n

test> parser.utils.repeat.tests.ex1 = check (parseText (repeat 3 (char ?x)) "xxx" === Right [?x, ?x, ?x])

parser.utils.repeatMinMax : Nat -> Nat -> Parser e Char a -> Parser e Char [a]
parser.utils.repeatMinMax min max p =
  go = cases
    (0, _) -> Parser.const []
    (n, 0) -> (Parser.or (p >>= ( x -> (Parser.map ((List.+:) x) (go (n - 1, 0))))) (Parser.const []))
    (n, m) -> p >>= ( x -> Parser.map ((List.+:) x) (go (n - 1, m - 1)))
  go (max, min)


test> parser.utils.repeatMinMax.tests.ex1 = check (parseText (repeatMinMax 1 3 (char ?x)) "xxx" === Right [?x, ?x, ?x])
test> parser.utils.repeatMinMax.tests.ex2 = check (parseText (repeatMinMax 1 4 (char ?x)) "xxx" === Right [?x, ?x, ?x])
test> parser.utils.repeatMinMax.tests.ex3 = check (parseText (repeatMinMax 1 4 (char ?x)) "xxxx" === Right [?x, ?x, ?x, ?x])
test> parser.utils.repeatMinMax.tests.ex4 = check (isLeft (parseText (repeatMinMax 4 5 (char ?x)) "xxx"))

-- ; NOTE: Backtrack when parsing each alternative
parser.IPv6address : Parser e Char Text
parser.IPv6address = oneOf [
  (parser.utils.repeat 6 (h16 <* (char ?:))) ^ ls32 $> cases (l,t) -> Text.join ":" (l :+ t),
  (string "::") *> (parser.utils.repeat 5 (h16 <* (char ?:))) ^ ls32 $> cases (l,t) -> Text.join ":" (":" +: l :+ t),
  (optional h16) ^ ((string "::") *> (parser.utils.repeat 4 (h16 <* (char ?:)))) ^ ls32 $> cases ((oh, l), t) -> (Optional.getOrElse "" oh) ++ (Text.join ":" (":" +: l :+ t)),
  (optional (h16 ^ (parser.utils.repeatMinMax 0 1 ((char ?:) *> h16)))) ^ ((string "::") *> (parser.utils.repeat 3 (h16 <* (char ?:)))) ^ ls32 $> cases
    ((oh, l), t) -> (Optional.getOrElse "" (Optional.map (cases (h, t) -> Text.join ":" (h +: t)) oh)) ++ (Text.join ":" (":" +: l :+ t)),
  (optional (h16 ^ (parser.utils.repeatMinMax 0 2 ((char ?:) *> h16)))) ^ ((string "::") *> (parser.utils.repeat 2 (h16 <* (char ?:)))) ^ ls32 $> cases
    ((oh, l), t) -> (Optional.getOrElse "" (Optional.map (cases (h, t) -> Text.join ":" (h +: t)) oh)) ++ (Text.join ":" (":" +: l :+ t)),
  (optional (h16 ^ (parser.utils.repeatMinMax 0 3 ((char ?:) *> h16)))) ^ ((string "::") *> (parser.utils.repeat 1 (h16 <* (char ?:)))) ^ ls32 $> cases
    ((oh, l), t) -> (Optional.getOrElse "" (Optional.map (cases (h, t) -> Text.join ":" (h +: t)) oh)) ++ (Text.join ":" (":" +: l :+ t)),
  (optional (h16 ^ (parser.utils.repeatMinMax 0 4 ((char ?:) *> h16)))) ^ ((string "::") *> ls32) $> cases
    (oh, l) -> (Optional.getOrElse "" (Optional.map (cases (h, t) -> Text.join ":" (h +: t)) oh)) ++ "::" ++ l,
  (optional (h16 ^ (parser.utils.repeatMinMax 0 5 ((char ?:) *> h16)))) ^ ((string "::") *> h16) $> cases
    (oh, l) -> (Optional.getOrElse "" (Optional.map (cases (h, t) -> Text.join ":" (h +: t)) oh)) ++ "++" ++ l,
  (optional (h16 ^ (parser.utils.repeatMinMax 0 6 ((char ?:) *> h16)))) <* (string "::") $>
    (oh -> (Optional.getOrElse "" (Optional.map (cases (h, t) -> Text.join ":" (h +: t)) oh)) ++ "::"
]

parser.IPv6address.test.verify text = check (parseText parser.IPv6address text === Right text)
test> parser.IPv6address.test.ex1 = parser.IPv6address.test.verify "ABCD:DCBA:AAAA:BBBB:DDDD:CCCC:123.123.123.123"
test> parser.IPv6address.test.ex2 = parser.IPv6address.test.verify "::AAAA:BBBB:DDDD:CCCC:123.123.123.123"
test> parser.IPv6address.test.ex3 = parser.IPv6address.test.verify "::AAAA:BBBB:DDDD:123.123.123.123"
test> parser.IPv6address.test.ex4 = parser.IPv6address.test.verify "9999:1111::AAAA:BBBB:DDDD:123.123.123.123"
test> parser.IPv6address.test.ex5 = parser.IPv6address.test.verify "2001:db8:85a3:0:0:8a2e:370:7334"

--                                          6( h16 ":" ) ls32
--             /                       "::" 5( h16 ":" ) ls32
--             / [ h16               ] "::" 4( h16 ":" ) ls32
--             / [ h16 *1( ":" h16 ) ] "::" 3( h16 ":" ) ls32
--             / [ h16 *2( ":" h16 ) ] "::" 2( h16 ":" ) ls32
--             / [ h16 *3( ":" h16 ) ] "::"    h16 ":"   ls32
--             / [ h16 *4( ":" h16 ) ] "::"              ls32
--             / [ h16 *5( ":" h16 ) ] "::"              h16
--             / [ h16 *6( ":" h16 ) ] "::"

parser.IPLiteral = (char ?[) *> (or parser.IPv6address parser.IPvFuture  ) <* (char ?]) $> (ip -> "[" ++ ip ++ "]")

parser.host : Parser e Char Text
parser.host = oneOf [
  parser.IPLiteral,
  parser.IPv4address,
  domain
]

parser.domain : Parser e Char Text
parser.domain = domainlabel ^ many0 ((char ?.) *> domainlabel) ^ (optional (char ?.)) $> (cases ((h, t), s) -> (Text.join "." (h +: t)) ++ (Optional.fold (_ -> "") (_ -> ".") s))

parser.domainlabel : Parser e Char Text
parser.domainlabel = ((many1 ascii.alphanum) ^ (many0 ((many1 (char ?-) ^ (many1 ascii.alphanum)) $> cases (a,b) -> a ++ b))) $> cases (a,b) -> Text.fromCharList (List.flatMap id (a +: b))
-- domainlabel = 1*ALPHANUM *(1*"-" 1*ALPHANUM)


parser.port : Parser e Char Text
parser.port = many1 ascii.digit $> Text.fromCharList

parser.pathAbempty : Parser e Char File
parser.pathAbempty = (many0 ((char ?/) *> parser.segment)) $> cases
  [] -> syntax.File.File [] ""
  (l :+ f) -> syntax.File.File (List.reverse l) f

parser.segment : Parser e Char Text
parser.segment = (many0 pChar) $> (Text.join "")

parser.unreserved : Parser e Char Char
parser.unreserved = oneOf [
  ascii.alphanum,
  char ?-,
  char ?.,
  char ?_,
  char ?~
]

parser.pctEncoded : Parser e Char Text
parser.pctEncoded = (char ?%) *> hexChar ^ hexChar $> cases (c1, c2) -> Text.fromCharList [?%, c1, c2]

parser.subDelims : Parser e Char Char
parser.subDelims = oneOf [
  char ?!,
  char ?$,
  char ?&,
  char ?',
  char ?*,
  char ?+,
  char ?;,
  char ?=
]

parser.pCharCharacter : Parser e Char Text
parser.pCharCharacter = Parser.map (compose Text.fromCharList List.singleton) (oneOf [
  parser.unreserved,
  parser.subDelims,
  (char ?:),
  (char ?@)
])

parser.pChar : Parser e Char Text
parser.pChar = oneOf [
  parser.pCharCharacter,
  parser.pctEncoded
]

parser.query : Parser e Char Text
parser.query = (many0 (oneOf [pChar,  (string "/"),  (string "?")])) $> (Text.join "")


parser.httpRaw : Parser e Char syntax.URL
parser.httpRaw = parser.scheme ^ ((string "://") *> authority) ^  pathAbempty ^ (optional ((char ??) *> query )) $> (cases (((s, t), f), oq) -> URL s t f oq)

parser.alternative5 : Parser e Char Expression -> (Parser e Char Expression)
parser.alternative5 dExpression =
  completeExpression = (many0 shebang) *> whitespace *> dExpression <* whitespace
  interpolation = string "${" *> completeExpression <* string "}"

  singleQuoteContinue : TextLiteral -> Parser e Char TextLiteral
  singleQuoteContinue tl = oneOf [
      interpolation >>= (exp -> singleQuoteContinue (addExpresionToTextLiteral exp tl))
    , string "'''" >>= (_ -> singleQuoteContinue (addTextToTextLiteral "''" tl))
    , string "''${" >>= (_ -> singleQuoteContinue (addTextToTextLiteral "${" tl))
    , string "''" $> 'tl
    , singleQuoteChar >>= (c -> singleQuoteContinue (addTextToTextLiteral c tl))
  ]

  singleQuoteLiteral = string "''" *> eol *> singleQuoteContinue (Chunks [] "") $> toDoubleQuoted

  doubleQuoteChunk : Parser e Char TextLiteral
  doubleQuoteChunk = oneOf [
    interpolation $> (ex -> (Chunks [("", ex)] ""))
  , (eq ?\\) *> doubleQuoteEscaped $> (c ->  (Chunks [] (Char.toText c)))
  , doubleQuoteChar $> (c ->  (Chunks [] (Char.toText c)))
  ]

  doubleQuotedLiteral : Parser e Char TextLiteral
  doubleQuotedLiteral = ((eq ?") .*> (many0 doubleQuoteChunk) <* (eq ?")) $> (List.foldLeft (TextLiteral.<>) (Chunks [] ""))

  textLiteral =
    Parser.label ((Parser.or doubleQuotedLiteral singleQuoteLiteral) $> Expression.TextLiteral) "literal"

  emptyRecordLiteral : Parser e Char Expression
  emptyRecordLiteral = equal *> optional (whitespace *> comma) *> whitespace $> '(RecordLiteral [])

  emptyRecordType : Parser e Char Expression
  emptyRecordType = Parser.const (RecordType [])

  nonEmptyRecordTypeOrLiteral : Parser e Char Expression
  nonEmptyRecordTypeOrLiteral =
    nonEmptyRecordType : Parser e Char Expression
    nonEmptyRecordType =
      entry = anyLabelOrSome <* (whitespace *> colon *> nonemptyWhitespace) ^ (dExpression <* whitespace)
      (sepBy1 entry (comma *> whitespace)) <* (optional (whitespace *> comma)) <* whitespace $> (compose RecordType Nonempty.toList)

    nonEmptyRecordLiteral : Parser e Char Expression
    nonEmptyRecordLiteral =
      keysValue : Parser e Char (Text, Expression)
      keysValue =
        ((anyLabelOrSome <* whitespace) ^
        (many0 (dot *> whitespace *> anyLabelOrSome <* whitespace)) ^
        ((optional (equal *> whitespace *> dExpression)) <* whitespace)) >>= cases
          ((firstLabel, keys), Optional.Some expression) -> Parser.const (firstLabel, List.foldRight (k -> e -> RecordLiteral [(k, e)]) expression keys)
          ((firstLabel, []), None) -> Parser.const (firstLabel, Variable firstLabel 0)
          ((_, _), None) -> Parser.fail (TrivialError unknown None (Set.singleton (Label "punned entry cannot contain dots")))
      combineRecordTerms : Expression ->{} Expression ->{} Expression
      combineRecordTerms e1 e2 = Expression.Operator e2 Operator.CombineRecordTerms e1
      combineRecords : [(Text, Expression)] ->{} [(Text, Expression)]
      combineRecords = compose Map.toList (Map.fromListWith combineRecordTerms)
      (sepBy1 keysValue (comma *> whitespace)) <* (optional (whitespace *> comma)) <* whitespace $>
        (compose RecordLiteral (compose combineRecords Nonempty.toList))

    oneOf [
    , nonEmptyRecordType
    , nonEmptyRecordLiteral
    ]

  recordTypeOrLiteral = oneOf [
    emptyRecordLiteral
  , nonEmptyRecordTypeOrLiteral
  , emptyRecordType
  ]

  unionType : Parser e Char Expression
  unionType =
    unionTypeEntry = (anyLabelOrSome <* whitespace) ^ (optional (colon *> nonemptyWhitespace *> dExpression <* whitespace))
    emptyUnionType = ((optional (bar *> whitespace)) *> closeAngle *> whitespace) $> '(UnionType [])
    nonEmptyUnionType =
      (optional (bar *> whitespace)) *> (sepBy1 unionTypeEntry (bar *> whitespace)) <* ((optional (bar *> whitespace)) *> closeAngle) $> (compose UnionType Nonempty.toList)
    Parser.label (openAngle *> whitespace *> (or nonEmptyUnionType emptyUnionType)) "literal"

  listLiteral : Parser e Char Expression
  listLiteral =
    emptyListLiteral = (optional (comma *> whitespace) *> closeBracket *> whitespace *> colon *> nonemptyWhitespace *> dExpression) $> EmptyList
    nonEmptyListLiteral = (optional (comma *> whitespace)) *> (sepBy1 dExpression (comma *> whitespace)) <*  (optional (comma *> whitespace) *> closeBracket) $> NonEmptyList
    Parser.label (openBracket *> whitespace *> (or nonEmptyListLiteral emptyListLiteral)) "literal"

  identifier : Parser e Char Expression
  identifier = label ^ (optional (whitespace *> at *> whitespace *> naturalLiteral)) >>= cases
    (x, Optional.Some n) ->
      match Natural.toMaybeNat n with
        Some m -> Parser.const (Variable x m)
        None -> Parser.fail (TrivialError unknown None (Set.singleton (Label "natural De Bruijn indeces are not supported")))
    (x, None) -> Parser.const (Variable x 0)

  builtinExpression : Parser e Char Expression
  builtinExpression =
    use syntax.Builtin Integer Date Time TimeZone
    peek >>= cases
      Optional.Some ?N -> Parser.oneOf [
          , (builtin "Natural/fold") >>= '(Parser.const (Builtin NaturalFold))
          , (builtin "Natural/build") >>= '(Parser.const (Builtin NaturalBuild))
          , (builtin "Natural/isZero") >>= '(Parser.const (Builtin NaturalIsZero))
          , (builtin "Natural/even") >>= '(Parser.const (Builtin NaturalEven))
          , (builtin "Natural/odd") >>= '(Parser.const (Builtin NaturalOdd))
          , (builtin "Natural/subtract") >>= '(Parser.const (Builtin NaturalSubtract))
          , (builtin "Natural/toInteger") >>= '(Parser.const (Builtin NaturalToInteger))
          , (builtin "Natural/show") >>= '(Parser.const (Builtin NaturalShow))
          , (builtin "None") >>= '(Parser.const (Builtin DhallNone))
          , (builtin "Natural") >>= '(Parser.const (Builtin Natural))
        ]
  --                       choice
  --                           , DoubleLit nan    <$ _NaN
  --                           ]
      Optional.Some ?I -> oneOf [
          , (builtin "Integer/clamp") >>= '(Parser.const (Builtin IntegerClamp))
          , (builtin "Integer/negate") >>= '(Parser.const (Builtin IntegerNegate))
          , (builtin "Integer/show") >>= '(Parser.const (Builtin IntegerShow))
          , (builtin "Integer/toDouble") >>= '(Parser.const (Builtin IntegerToDouble))
          , (builtin "Integer") >>= '(Parser.const (Builtin Integer))
          ]

      Optional.Some ?D -> oneOf [
          , (builtin "Date") >>= '(Parser.const (Builtin Date))
          , (builtin "Double/show") >>= '(Parser.const (Builtin DoubleShow))
          , (builtin "Double") >>= '(Parser.const (Builtin Double))
          ]

      Optional.Some ?L -> oneOf [
        , (builtin "List/build") >>= '(Parser.const (Builtin ListBuild))
        , (builtin "List/fold") >>= '(Parser.const (Builtin ListFold))
        , (builtin "List/length") >>= '(Parser.const (Builtin ListLength))
        , (builtin "List/head") >>= '(Parser.const (Builtin ListHead))
        , (builtin "List/last") >>= '(Parser.const (Builtin ListLast))
        , (builtin "List/indexed") >>= '(Parser.const (Builtin ListIndexed))
        , (builtin "List/reverse") >>= '(Parser.const (Builtin ListReverse))
        , (builtin "List") >>= '(Parser.const (Builtin List))
        ]

      Optional.Some ?O -> (builtin "Optional") >>= '(Parser.const (Builtin Optional))
      Optional.Some ?B -> (builtin "Bool") >>= '(Parser.const (Builtin Bool))
      Optional.Some ?S -> (builtin "Sort") >>= '(Parser.const (Constant Sort))

      Optional.Some ?T -> oneOf [
        , (builtin "Text/replace") >>= '(Parser.const (Builtin TextReplace))
        , (builtin "Text/show") >>= '(Parser.const (Builtin TextShow))
        , (builtin "Text") >>= '(Parser.const (Builtin Text))
        , (builtin "TimeZone") >>= '(Parser.const (Builtin TimeZone))
        , (builtin "Time") >>= '(Parser.const (Builtin Time))
        , (builtin "True") >>= '(Parser.const (Builtin True))
        , (builtin "Type") >>= '(Parser.const (Constant Type))
      ]
      Optional.Some ?F ->  (builtin "False") >>= '(Parser.const (Builtin False))
      Optional.Some ?K ->  (builtin "Kind") >>= '(Parser.const (Constant Kind))

      _ -> Parser.fail (TrivialError unknown None (Set.singleton (Label "no builtin")))

  parenExpression : Parser e Char Expression
  parenExpression = openParen *> whitespace *> dExpression <* (whitespace *> closeParen)

  primitiveExpression =
    oneOf
      [ temporalLiteral
      , doubleLiteral $> DoubleLiteral
      , naturalLiteral $> NaturalLiteral
      , integerLiteral $> IntegerLiteral
      , textLiteral
      , openBrace *> whitespace *> (optional (comma *> whitespace)) *> recordTypeOrLiteral <* closeBrace
      , unionType
      , listLiteral
      , identifier
      , builtinExpression
      , parenExpression
      ] -- TODO

  selectorExpression =
    recordType = openParen *> whitespace *> dExpression <* whitespace <* closeParen
    field x e = Field e x
    projectBySet xs e = ProjectByLabels e xs
    projectByExpression ex e = ProjectByType e ex

    (primitiveExpression ^ (many0 (whitespace *> tokens.dot *> whitespace *> oneOf [
      , anyLabel $> field
      , labels $> projectBySet
      , recordType $> projectByExpression
    ]))) $> cases (a, b) -> List.foldLeft (e k -> k e) a b

  completionExpression =
    selectorExpression ^ (optional (whitespace*> doubleColon *> whitespace *> selectorExpression)) $> cases
      (a, None) -> a
      (a, Optional.Some b) -> Completion a b


  http : Parser e Char Expression -> Parser e Char syntax.ImportType
  http dImportExpression = httpRaw ^ (optional (whitespace *> (string "using") *> nonemptyWhitespace *> dImportExpression)) $> cases (url, oExpression) -> Remote url oExpression
  -- TODO
  -- http dImportExpression = httpRaw ^ (optional (whitespace *> (string "using") *> nonemptyWhitespace)) $> cases (url, oExpression) -> Remote url None


  simpleLabelNextChar : Char -> Boolean
  simpleLabelNextChar c = isAlphaNum c || (List.contains c [ ?-, ?/, ?_ ])


  importType : Parser e Char Expression -> Parser e Char ImportType
  importType dImportExpression = oneOf [
    (string "missing") *> peek >>= cases
      (Optional.Some c) | simpleLabelNextChar c -> Parser.fail (TrivialError unknown None Set.empty)
      _ -> Parser.const Missing,
    parser.local,
    http dImportExpression,
    parser.env
  ]

  importHashed dImportExpression = (importType dImportExpression) ^ (optional (nonemptyWhitespace *> hash))

  import dImportExpression = (importHashed dImportExpression) ^ (optional (whitespace  *> (string "as") *> nonemptyWhitespace *> (or (string "Text") (string "Location")))) $> cases
    ((importType, hash), None) -> Import importType Code hash
    ((importType, hash), Some "Text") -> Import importType RawText hash
    ((importType, hash), Some "Location") -> Import importType Location hash

  -- importExpression = or import completionExpression

  importExpressionRec : '(Parser e Char Expression) -> Parser e Char Expression
  importExpressionRec p =
    dImportExpression = Parser.delay p
    or (import dImportExpression) completionExpression


  importExpression = fix importExpressionRec

  applicationExpressionWithInfo : Parser e Char (ApplicationExprInfo, Expression)
  applicationExpressionWithInfo =
    oneOf [
      (string "merge" *> nonemptyWhitespace *> importExpression <* nonemptyWhitespace) $> (a -> (b -> Merge a b None, Some "second arg to 'merge'"))
    , (string "Some" *> nonemptyWhitespace) $> '(DhallSome, Some "argument to 'Some'")
    , (string "toMap" *> nonemptyWhitespace) $> '(a -> ToMap a None, Some "argument to 'toMap'")
    , Parser.const (id, None)
    ] >>= cases
      (f, maybeMessage) ->
          importExpression ^ (many0 (nonemptyWhitespace *> importExpression)) $> cases
        (a, bs) ->
          c = foldLeft Application (f a) bs
          info = match (maybeMessage, bs) with
            (Optional.Some _, []) -> NakedMergeOrSomeOrToMap
            (None, []) -> ImportExpr
            _ -> ApplicationExpr
          (info, c)

  applicationExpression = applicationExpressionWithInfo $> Tuple.at2

  operatorExpression firstApplicationExpression =
    nil : (Parser e Char Expression, Parser e Char Expression)
    nil = (firstApplicationExpression, applicationExpression)
    cons : (Parser e Char (Expression -> Expression -> Expression)) -> (Parser e Char Expression, Parser e Char Expression) -> (Parser e Char Expression, Parser e Char Expression)
    cons operatorParser = cases (p0, p) ->
        ( makeOperatorExpression p0 operatorParser p
        , makeOperatorExpression p  operatorParser p
        )
    makeOperatorExpression firstSubExpression operatorParser subExpression =
      firstSubExpression ^
        (many0 ((whitespace *> operatorParser) ^ subExpression $> cases (op, r0) -> (l -> op l r0))) $> cases
        (a, bs) -> List.foldLeft (x f -> f x) a bs
    List.foldRight cons nil operatorParsers

  alternatives : ApplicationExprInfo -> Expression -> Parser e Char Expression -> Parser e Char Expression -> Parser e Char Expression
  alternatives a0Info a0 parseFirstOperatorExpression parseOperatorExpression =

    alternative5A : Parser e Char Expression
    alternative5A = match a0Info with
      ImportExpr ->
        many1 ((nonemptyWhitespace *> _with *> nonemptyWhitespace) *>
        (sepBy1 anyLabel (whitespace *> dot *> whitespace)) <* (whitespace *> equal *> whitespace) ^
          parseOperatorExpression $> cases (keys, value) -> (e -> With e keys value)) $> (bs -> List.foldLeft (e -> f -> f e) a0 bs)
      _ -> Parser.fail (TrivialError unknown None (Set.empty))

    alternative5B : Parser e Char Expression
    alternative5B =
      alternative5B0 : Expression -> Parser e Char Expression
      alternative5B0 a = (arrow *> whitespace *> dExpression <* whitespace) $> (b -> Forall "_" a b)

      alternative5B1 : Expression -> Parser e Char Expression
      alternative5B1 a = (colon *> nonemptyWhitespace *> (match (a, a0Info) with
        (Merge c d None, NakedMergeOrSomeOrToMap) -> dExpression $> (b -> Merge c d (Some b))
        (ToMap c None, NakedMergeOrSomeOrToMap) -> dExpression $> (b -> ToMap c (Some b))
        _ -> dExpression $> (b -> Annotation a b)))

      alternative5B2 a = Parser.const a -- TODO a
      (parseFirstOperatorExpression <* whitespace) >>= (a -> oneOf [alternative5B0 a, alternative5B1 a, alternative5B2 a])
    oneOf [alternative5A, alternative5B]

  applicationExpressionWithInfo >>= cases
    (a0Info, a0) ->
      match operatorExpression(Parser.const a0) with
        (parseFirstOperatorExpression, parseOperatorExpression) ->
          alternatives a0Info a0 parseFirstOperatorExpression parseOperatorExpression

parser.recExpression : '(Parser e Char Expression) -> (Parser e Char Expression)
parser.recExpression expression =
  dExpression = Parser.delay expression

  oneOf [
    alternative0 dExpression
  , alternative1 dExpression
  , alternative2 dExpression
  , alternative3 dExpression
  , alternative4 dExpression
  , alternative5 dExpression
  ]

parser.rootExpression : Parser e Char Expression
parser.rootExpression = fix recExpression

parser.util.printError : Error Void Char -> Text
parser.util.printError = cases
  TrivialError loc maybeError hints ->
    "Syntax error at " ++ (printLocation loc)
      ++ (Optional.getOrElse "" (Optional.map (e -> "\nFound: '" ++ (printErrorItem e)) maybeError) ++ "'")
      ++ (match Set.toList hints with
        [] -> ""
        [e] -> "\nExpected " ++ printErrorItem e
        l -> "\nExpected one of (" ++ (Text.join ", " (List.map printErrorItem l)) ++ ")")
      ++ "\n"
  FancyError loc errors ->
    "Error at " ++ (printLocation loc)
      ++ (match Set.toList errors with
        [] -> ""
        l -> "\n" ++ (Text.join "\n" (List.map printErrorFancy l)))
      ++ "\n"

parser.util.printErrorItem : ErrorItem Char -> Text
parser.util.printErrorItem = cases
  Label t -> "a " ++ t
  Tokens ts -> Text.fromCharList ts
  EndOfInput -> "<eof>"

parser.util.printErrorFancy: ErrorFancy Void -> Text
parser.util.printErrorFancy = cases
  ErrorIndentation ord n1 n2 -> "Error indentation TODO"
  ErrorFail text -> text

use base.IO.Filepath Filepath
parser.util.printLocation : Location -> Text
parser.util.printLocation = cases
  Range fp lineStart colStart lineEnd colEnd ->  "TODO"
  Location.Location fp (Line line) (Col col) -> (base.IO.FilePath.toText fp) ++ ":(" ++ (Nat.toText line) ++ ", " ++ (Nat.toText col) ++ ")"

parser.completeExpression =  (many0 shebang) *> whitespace *> rootExpression <* whitespace <* (optional lineCommentPrefix)

parser.twoDigits = ascii.digit +:> (ascii.digit +:> Parser.const "")

parser.validTwoDigits : Text -> Nat  -> Nat  -> Parser e Char Nat
parser.validTwoDigits name min max = twoDigits >>= (s -> match Nat.fromText s with
  Optional.Some n | (n >= min) && (n <= max) -> Parser.const n
  _ -> failMessage (name ++ " '" ++ s ++ "' must be in the range " ++ (if min < 10 then "0" else "") ++ (Nat.toText min) ++ "-" ++ (Nat.toText max)))


parser.dateMonth = validTwoDigits "month" 1 12
parser.dateDay = validTwoDigits "day" 1 31
parser.dateYear =  ascii.digit +:> (ascii.digit +:> (ascii.digit +:> (ascii.digit +:> Parser.const ""))) >>= (s -> match Nat.fromText s with
  Optional.Some n -> Parser.const n
  _ -> failMessage ("can't parse year" ++ s))

parser.timeHour = validTwoDigits "hour" 0 23
parser.timeMinutes = validTwoDigits "minutes" 0 59
parser.timeSeconds = validTwoDigits "seconds" 0 59

parser.timeSecfrac : Parser e Char Text
parser.timeSecfrac = (eq ?.) *> (many1 digit $> Text.fromCharList)

parser.checkDate : Nat -> Nat -> Nat -> Boolean
parser.checkDate y m d = match m with
  1 -> d <= 31
  2 -> d <= (if (Nat.mod y 4 == 0) then 29 else 28) -- TODO
  3 -> d <= 31
  4 -> d <= 30
  5 -> d <= 31
  6 -> d <= 30
  7 -> d <= 31
  8 -> d <= 31
  9 -> d <= 30
  10 -> d <= 31
  11 -> d <= 30
  12 -> d <= 31


parser.fullDate : Parser e Char Date
parser.fullDate =
  use support.Date Date
  dateYear ^ (minus *> dateMonth) ^ (minus *> dateDay) >>= (cases -- TODO check day with regards to month/year
    ((y, m), d) | checkDate y m d -> Parser.const (Date y m d)
    ((y, m), d) -> failMessage ("Invalid date " ++ (Nat.toText y) ++ "-" ++(Nat.toText m) ++ "-" ++(Nat.toText d)))

parser.partialTime : Parser e Char Time
parser.partialTime =
  use support.Time Time
  timeHour ^ (colon *> timeMinutes) ^ (colon *> timeSeconds) ^ (optional timeSecfrac) >>= cases
    (((h, m), s), None) -> Parser.const (Time h m s 0)
    (((h, m), s), Optional.Some frac) -> match (Nat.fromText ((Nat.toText s) ++ frac)) with
      Optional.Some n -> Parser.const (Time h m n (Text.size frac))
      None -> failMessage ("cannot parse fractional part '" ++ frac ++ "'")

parser.timeNumoffset : Parser e Char TimeZone
parser.timeNumoffset =
  use support.TimeZone TimeZone
  (or plus minus) ^ timeHour ^ (colon *> timeMinutes) $> cases
    ((?+,  h), m) -> TimeZone (Nat.toInt (h * 60 + m))
    ((?-,  h), m) -> TimeZone (-1 * (Nat.toInt (h * 60 + m)))


parser.timeOffset : Parser e Char TimeZone
parser.timeOffset =
  use support.TimeZone TimeZone
  oneOf [
    timeNumoffset,
    char ?Z $> '(TimeZone +0)
  ]

parser.temporalLiteral : Parser e Char Expression
parser.temporalLiteral = oneOf [
  fullDate ^ ((or (char ?t) (char ?T)) *> partialTime) ^  timeOffset $> cases ((date, time), timeZone) -> RecordLiteral [("date", DateLiteral date), ("time", TimeLiteral time), ("timeZone", TimeZoneLiteral timeZone)],
  fullDate ^ ((or (char ?t) (char ?T)) *> partialTime) $> cases (date, time) -> RecordLiteral [("date", DateLiteral date), ("time", TimeLiteral time)],
  partialTime ^ timeOffset $> cases (time, timeZone) -> RecordLiteral [("time", TimeLiteral time), ("timeZone", TimeZoneLiteral timeZone)],
  fullDate $> DateLiteral,
  partialTime $> TimeLiteral,
  timeNumoffset $> TimeZoneLiteral
]

