use syntax
use syntax.TextLiteral Chunks
use syntax.Constant Type Kind Sort
use syntax.Builtin Optional Natural Integer Double Text List Date Time TimeZone NaturalBuild NaturalFold NaturalIsZero NaturalEven NaturalOdd NaturalToInteger NaturalShow NaturalSubtract IntegerToDouble IntegerShow IntegerNegate IntegerClamp DoubleShow ListBuild ListFold ListLength ListHead ListLast ListIndexed ListReverse TextShow TextReplace Bool True False
use syntax Expression
use syntax.Expression Lambda Forall Let Variable If Merge ToMap EmptyList NonEmptyList Annotation Operator Application Field ProjectByLabels ProjectByType Completion Assert With DoubleLiteral NaturalLiteral IntegerLiteral TextLiteral RecordType RecordLiteral UnionType DateLiteral TimeLiteral TimeZoneLiteral Operator Builtin Constant
use syntax.Operator Or And Equal NotEqual Plus Times TextAppend ListAppend CombineRecordTerms Prefer CombineRecordTypes Alternative Equivalent Some

utils.escapeText: Text -> Text
utils.escapeText t =
  escape : Char -> [Char]
  escape = cases
    ?$ -> [?\\, ?u, ?0, ?0, ?2, ?4]
    ?" -> [?\\, ?"]
    ?\b -> [?\\, ?b]
    ?\f -> [?\\, ?f]
    ?\n -> [?\\, ?n]
    ?\r -> [?\\, ?r]
    ?\t -> [?\\, ?t]
    ?\\ -> [?\\, ?\\]
    c ->
      n = Char.toNat c
      if n <= 32 then
        hexEncoding = Natural.toHex (Natural.fromNat n)
        Text.toCharList ((if n < 16 then "\\u000" else "\\u00") ++ hexEncoding)
      else [c]
  "\"" ++ Text.fromCharList (List.flatMap escape (Text.toCharList t)) ++ "\""

utils.splitOn: Text -> Text -> [Text]
utils.splitOn separator text =
  sep = Text.toCharList separator
  t = Text.toCharList text
  go : [Char] -> [Char] -> [[Char]] -> [[Char]]
  go l cur acc = match l with
    [] -> acc :+ cur
    (h +: t) -> match List.stripPrefix sep l with
      None -> go t (cur :+ h) acc
      Optional.Some l -> go l [] (acc :+ cur)
  List.map Text.fromCharList (go t [] [])

use Text

utils.printExpression: Expression -> Text
utils.printExpression = cases
  Lambda x A0 b0 -> "λ(" ++ x ++ ": " ++ (printExpression A0) ++ ") -> " ++ printExpression b0
  Forall x A0 B0 -> "∀(" ++ x ++ ": " ++ (printExpression A0) ++ ") -> " ++ printExpression B0
  Let x t a0 b0 ->
    ot = match t with
      Optional.Some T -> " : " ++ (printExpression T)
      None -> ""
    "let " ++ x ++ ot ++ " = " ++ (printExpression a0) ++ " in " ++ (printExpression b0)
  Variable x n -> if (Natural.isZero n) then x else x ++ "@" ++ (Natural.toDecimalText n)
  If t0 l0 r0 -> "if " ++ (printExpression t0) ++ " then " ++ (printExpression l0) ++ " else " ++ (printExpression r0)
  Merge t0 u0 t -> "merge " ++ (printExpression t0) ++ " " ++ (printExpression u0) ++ (Optional.getOrElse "" (Optional.map (e -> " : " ++ printExpression(e)) t))
  ToMap t0 t -> "toMap " ++ (printExpression t0) ++ (Optional.getOrElse "" (Optional.map (e -> " : " ++ printExpression(e)) t))
  EmptyList T0 -> "[] : " ++ (printExpression T0)
  NonEmptyList ts0 -> "[" ++ (List.foldLeft (++) "" (List.intersperse ", " (List.map printExpression (Nonempty.toList ts0)))) ++ "]"
  Annotation t0 T0 -> (printExpression t0) ++ ": " ++ (printExpression T0)
  Operator l0 op r0 -> (printExpression l0) ++ (printOperator op) ++ (printExpression r0)
  Application f0 a0 -> (printExpression f0) ++ " " ++ (printExpression a0)
  Field t0 y -> "(" ++ (printExpression t0) ++ ")." ++ y
  ProjectByLabels t0 xs -> "(" ++ (printExpression t0) ++ ").{" ++ (List.foldLeft (++) "" (List.intersperse ", " xs)) ++ "}"
  ProjectByType t0 T0 -> "(" ++ (printExpression t0) ++ ").(" ++ (printExpression T0) ++ ")"
  Completion T0 r0 -> (printExpression T0) ++ "::" ++ (printExpression r0)
  Assert T0 -> "assert : " ++ (printExpression T0)
  With e0 ks v0 -> (printExpression e0) ++ (Text.join "." (Nonempty.toList ks)) ++ " = " ++ (printExpression v0)
  DoubleLiteral d -> Float.toText d
  NaturalLiteral n -> Natural.toDecimalText n
  IntegerLiteral n -> Integer.toText n
  TextLiteral (Chunks xys0 z) -> (List.foldLeft (++) "" (List.intersperse ", " (List.map (cases (t, ex) -> t ++ "{" ++ (printExpression ex) ++ "}") xys0))) ++ z
  RecordType ks0 -> "{" ++ (Text.join ", " (List.map (cases (a, e) -> a ++ ": " ++ (printExpression e)) ks0)) ++ "}"
  RecordLiteral ks0 -> "{" ++ (Text.join ", " (List.map (cases (a, e) -> a ++ " = " ++ (printExpression e)) ks0)) ++ "}"
  UnionType ks0 ->
    unionElements = List.map (cases
    (k, None) -> k
    (k, Optional.Some ex) -> k ++ ": " ++ (printExpression ex)) ks0
    "<" ++ (Text.join " | " unionElements)++ ">"
  DhallSome a0 -> "Some " ++ (printExpression a0)
  Builtin b -> printBuiltin b
  Constant c -> printConstant c
  DateLiteral (Date.Date y m d) -> (Nat.toText y) ++ "-" ++ (Nat.toText m) ++ "-" ++ (Nat.toText d)
  TimeLiteral (Time.Time h m s p) -> (Nat.toText h) ++ ":" ++ (Nat.toText m) ++ ":" ++ (Nat.toText (s / (pow 10  p)))
  TimeZoneLiteral (TimeZone.TimeZone minutes) ->
      positive = minutes Int.>= +0
      absMin = if positive then Int.truncate0 minutes else Int.truncate0 (Int.negate minutes)
      (if positive then "+" else "-") ++ (Nat.toText (absMin / 60)) ++ ":" ++ (Nat.toText (Nat.mod absMin 60))

utils.printConstant : Constant -> Text
utils.printConstant = cases
  Type -> "Type"
  Kind -> "Kind"
  Sort -> "Sort"

utils.printBuiltin : Builtin -> Text
utils.printBuiltin = cases
  NaturalBuild -> "Natural/build"
  NaturalFold -> "Natural/fold"
  NaturalIsZero -> "Natural/isZero"
  NaturalEven -> "Natural/even"
  NaturalOdd -> "Natural/odd"
  NaturalToInteger -> "Natural/toInteger"
  NaturalShow -> "Natural/show"
  NaturalSubtract -> "Natural/subtract"
  IntegerToDouble -> "Integer/toDouble"
  IntegerShow -> "Integer/show"
  IntegerNegate -> "Integer/negate"
  IntegerClamp -> "Integer/clamp"
  DoubleShow -> "Double/show"
  ListBuild -> "List/build"
  ListFold -> "List/fold"
  ListLength -> "List/length"
  ListHead -> "List/head"
  ListLast -> "List/last"
  ListIndexed -> "List/indexed"
  ListReverse -> "List/reverse"
  TextShow -> "Text/show"
  TextReplace -> "Text/replace"
  Bool -> "Bool"
  Optional -> "Optional"
  Natural -> "Natural"
  Integer -> "Integer"
  Double -> "Double"
  Text -> "Text"
  List -> "List"
  True -> "True"
  False -> "False"
  DhallNone -> "None"
  Date -> "Date"
  Time -> "Time"
  TimeZone -> "TimeZone"

utils.printOperator : Operator -> Text
utils.printOperator = cases
  Or -> "||"
  Plus -> "+"
  TextAppend -> "++"
  ListAppend -> "#"
  And -> "&&"
  CombineRecordTerms -> "∧"
  Prefer -> "⫽"
  CombineRecordTypes -> "⩓"
  Times -> "*"
  Equal -> "=="
  NotEqual -> "!="
  Equivalent -> "=="
  Alternative -> "?"
