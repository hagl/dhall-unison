use syntax Expression
use binary
use binary Term
use syntax.Constant
use support.Integer Integer
use utils
use type_inference
use base.Natural <=
use Optional Some
use List
use Text

testsuite.updateResults : (Nat, Nat) -> (Nat, Nat) ->(Nat, Nat)
testsuite.updateResults = cases (success0, fail0) -> cases (success1, fail1) -> (success0 + success1, fail0 + fail1)

testsuite.printTestStatus : Text -> (Nat, Nat) ->  ()
testsuite.printTestStatus dir = cases (success, fail) -> printLine(
      (Nat.toText (success + fail)) ++ " total tests ( âœ… " ++
      (Nat.toText success) ++ " passed, ðŸš« " ++ (Nat.toText fail) ++ " failed) in directory " ++ dir)

testsuite.runTestsRecursive : Text -> Text-> (Text -> Text -> Boolean) -> (Nat, Nat)
testsuite.runTestsRecursive testDirectory testSuffix testRunner =
  removeSuffix : Text -> Text -> Optional Text
  removeSuffix suffix text =
    if size suffix > size text then None
      else
        d = Int.truncate0 (size text - (size suffix))
        if drop d text == suffix then Some (take d text) else None

  printLine ("Running tests in " ++ testDirectory)
  fp = FilePath.FilePath testDirectory
  contents = io.directoryContents fp
  tests = filterMap (removeSuffix testSuffix) contents
  -- tests = filter ((==) "RecordProjectionByTypeJudgmentalEquality") (filterMap (removeSuffix testSuffix) contents)
  isSubfolder f =
    path = testDirectory ++ "/" ++ f
    if io.isDirectory (FilePath.FilePath path) && (f != ".") && (f != "..") then Some(path) else None
  subdirs = filterMap isSubfolder contents
  test t =
    result = testRunner testDirectory t
    printLine ((if result then "âœ…" else "ðŸš«")++ " " ++ t)
    if (result) then (1, 0) else (0, 1)
  folderTestResult = List.foldLeft (acc -> t -> updateResults acc (test t)) (0, 0) tests
  result = List.foldLeft (acc -> d -> updateResults acc (runTestsRecursive d testSuffix testRunner)) folderTestResult subdirs
  printTestStatus testDirectory result
  result

testsuite.parseTestcase : FilePath -> Either Text Expression
testsuite.parseTestcase inputPath =
  input = io.openFile inputPath FileMode.Read
  inputBytes = getBytes input (base.io.getFileSize inputPath)
  inputText = Text.fromUtf8 inputBytes
  io.closeFile input
  parseText parser.completeExpression inputText

testsuite.encodeExpression : Expression -> Bytes
testsuite.encodeExpression expression =
  encoded = encode expression
  Term.toBytes encoded

testsuite.printOptional : Optional Expression -> Text
testsuite.printOptional optEx = Optional.fold '("None") printExpression optEx

testsuite.printEither : Either Text Expression -> Text
testsuite.printEither = Either.fold (t -> "Left: " ++ t) printExpression

testsuite.parseSuccessTest : Text -> Text -> Boolean
testsuite.parseSuccessTest testDir name =
  use Text
  testPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "A.dhall")
  bytes = Optional.map encodeExpression (Either.right (parseTestcase testPath))
  checkPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "B.dhallb")
  check = io.openFile checkPath FileMode.Read
  checkBytes = getBytes check (base.io.getFileSize checkPath)
  io.closeFile check
  success = bytes === Some checkBytes
  success

testsuite.parseFailureTest : Text -> Text -> Boolean
testsuite.parseFailureTest testDir name =
  use Text
  inputPath = FilePath.FilePath (testDir ++ "/" ++ name ++ ".dhall")
  input = io.openFile inputPath FileMode.Read
  inputBytes = getBytes input (base.io.getFileSize inputPath)
  io.closeFile input
  match catch '(
    match parseText parser.completeExpression (Text.fromUtf8 inputBytes) with
      Right exp -> false
      _ -> true
  ) with
    Left (Failure _ t _ ) ->
      printLine("Exception: " ++ t)
      true
    Right result -> result

testsuite.alphaNormalizationTest : Text -> Text -> Boolean
testsuite.alphaNormalizationTest testDir name =
  use Text
  testPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "A.dhall")
  use .dhall.trunk.alpha_normalization
  use .dhall.trunk.utils
  normalized = Optional.map alphaNormalize (Either.right (parseTestcase testPath))
  bytes = Optional.map encodeExpression normalized
  checkPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "B.dhall")
  checkBytes = Optional.map encodeExpression (Either.right (parseTestcase checkPath))
  result = bytes === checkBytes
  if (result) then true
  else
    printLine("Normalized:\n" ++ (printOptional normalized))
    printLine("Correct:\n" ++ (printEither (parseTestcase checkPath)))
    false

testsuite.normalizationTest : Text -> Text -> Boolean
testsuite.normalizationTest testDir name =
  use Text
  testPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "A.dhall")
  dirs = List.reverse (utils.splitOn "/" (testDir))
  use .dhall.trunk.alpha_normalization
  use .dhall.trunk.utils

  normalized = match parseTestcase testPath with
    Left err -> Debug.watch ("Parse error : " ++ err) None
    Right parsed ->
      match import.resolve (Path Here (File dirs (name ++ "A.dhall"))) parsed with
        Left msg -> Debug.watch ("Import error : " ++ msg) None
        Right resolved -> Optional.Some (betaNormalize resolved)

  bytes = Optional.map encodeExpression normalized
  checkPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "B.dhall")
  checkBytes = Optional.map encodeExpression (Either.right (parseTestcase checkPath))
  result = bytes === checkBytes
  if (result) then true
  else
    printLine("Normalized:\n" ++ (printOptional normalized))
    printLine("Correct:\n" ++ (printEither (parseTestcase checkPath)))
    false

testsuite.typeInferenceTest : Text -> Text -> Boolean
testsuite.typeInferenceTest testDir name =
  use Text
  testPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "A.dhall")
  dirs = List.reverse (utils.splitOn "/" (testDir))
  use type_inference
  use .dhall.trunk.utils

  resolvedOpt =
    if name == "prelude" -- prelude test takes multiple hours
    then None
    else
      match parseTestcase testPath with
        Left err -> Debug.watch ("Parse error : " ++ err) None
        Right parsed ->
          match import.resolve (Path Here (File dirs (name ++ "A.dhall"))) parsed with
            Left msg -> Debug.watch ("Import error : " ++ msg) None
            Right resolved -> Optional.Some resolved
            -- Right resolved -> Optional.Some (betaNormalize resolved)

  inferredType = match resolvedOpt with
    None -> None
    Optional.Some parsed ->
      match typeCheck Context.empty parsed with
        Left msg -> Debug.watch ("Typecheck error : " ++ msg) None
        Right inferred -> Optional.Some inferred

  match inferredType with
    None -> false
    Some _ ->
      bytes = Optional.map encodeExpression inferredType
      checkPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "B.dhall")
      checkBytes = Optional.map encodeExpression (Either.right (parseTestcase checkPath))
      result = bytes === checkBytes
      if (result) then true
      else
        printLine("Type:\n" ++ (printOptional inferredType))
        printLine("Correct:\n" ++ (printEither (parseTestcase checkPath)))
        false

testsuite.typeInferenceFailureTest : Text -> Text -> Boolean
testsuite.typeInferenceFailureTest testDir name =
  testPath = Debug.watch (name) FilePath.FilePath (testDir ++ "/" ++ name ++ ".dhall")
  print optEx = Optional.getOrElse "None" (Optional.map printExpression optEx)

  match parseTestcase testPath with
    Left err -> Debug.watch ("Parse error:" ++ err) false
    Right parsed ->
      match typeCheck Context.empty parsed with
        Right t -> Debug.watch ("Expected type error, but got  " ++ printExpression t) false
        Left _ -> true

testsuite.importTest : Text -> Text -> Boolean
testsuite.importTest testDir name =
  use Text
  dirs = List.reverse (utils.splitOn "/" (testDir))
  use type_inference
  use .dhall.trunk.utils
  normalizedExpressionA = match parseTestcase (FilePath.FilePath (testDir ++ "/" ++ name ++ "A.dhall")) with
    Left err -> Debug.watch ("Parse error : " ++ err) None
    Right parsed ->
      match import.resolve (Path Here (File dirs (name ++ "A.dhall"))) parsed with
        Left msg -> Debug.watch ("Import error : " ++ msg) None
        Right resolved -> Optional.Some (betaNormalize resolved)

  normalizedExpressionB = match parseTestcase (FilePath.FilePath (testDir ++ "/" ++ name ++ "B.dhall")) with
    Left err -> Debug.watch ("Parse error : " ++ err) None
    Right parsed ->
      match import.resolve (Path Here (File dirs (name ++ "B.dhall"))) parsed with
        Left msg -> Debug.watch ("Import error : " ++ msg) None
        Right resolved -> Optional.Some (betaNormalize resolved)

  if normalizedExpressionA === normalizedExpressionB
    then true
    else
      printLine("Actual:\n" ++ (printOptional normalizedExpressionA))
      printLine("Correct:\n" ++ (printOptional normalizedExpressionB))
      false


testsuite.semanticHashTest : Text -> Text -> Boolean
testsuite.semanticHashTest testDir name =
  use Text
  use type_inference
  use .dhall.trunk.utils
  dirs = Debug.watch name (List.reverse (utils.splitOn "/" (testDir)))
  hash = match parseTestcase (FilePath.FilePath (testDir ++ "/" ++ name ++ "A.dhall")) with
    Left err -> Debug.watch ("Parse error : " ++ err) None
    Right parsed ->
      match import.resolve (Path Here (File dirs (name ++ "A.dhall"))) parsed with
        Left msg -> Debug.watch ("Import error : " ++ msg) None
        Right resolved -> Optional.Some ("sha256:" ++ (import.hashExpression resolved))

  use Text
  checkPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "B.hash")
  check = io.openFile checkPath FileMode.Read
  checkBytes = getBytes check (base.io.getFileSize checkPath)
  checkHash = Text.trim (Text.fromUtf8 checkBytes)
  io.closeFile check
  success = Optional.map ((Text.==) checkHash) hash === Some true
  success

testsuite.binaryDecodeSuccessTest : Text -> Text -> Boolean
testsuite.binaryDecodeSuccessTest testDir name =
  use Text
  testPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "A.dhallb")
  inputBytes =
    bracket
      '(openFile (testPath) Read)
      closeFile
      (fileHandle -> (getBytes fileHandle (base.io.getFileSize testPath)))
  decodedExpression = match binary.Term.fromBytes inputBytes with
    Left err ->
      printLine ("Decoding error: " ++ err)
      Left err
    Right decoded -> binary.decodeTerm decoded
  checkPath = FilePath.FilePath (testDir ++ "/" ++ name ++ "B.dhall")
  checkExpression = parseTestcase checkPath
  if decodedExpression === checkExpression
    then true
    else
      printLine("Actual:\n" ++ (printEither decodedExpression))
      printLine("Correct:\n" ++ (printEither checkExpression))
      false

testsuite.binaryDecodeFailureTest : Text -> Text -> Boolean
testsuite.binaryDecodeFailureTest testDir name =
  use Text
  testPath = FilePath.FilePath (testDir ++ "/" ++ name ++ ".dhallb")
  inputBytes =
    bracket
      '(openFile (testPath) Read)
      closeFile
      (fileHandle -> (getBytes fileHandle (base.io.getFileSize testPath)))
  decodedExpression = match binary.Term.fromBytes inputBytes with
    Left err ->
      Left err
    Right decoded -> binary.decodeTerm decoded
  if Either.isLeft decodedExpression
    then true
    else
      printLine("Expected decoding error but got :\n" ++ (printEither decodedExpression))
      false

{{ {perfTest} measures the time needed to parse the type of the Dhall prelude, which is around 700 lines of Dhall code.

You need to specify the path of a copy of [https://github.com/dhall-lang/dhall-lang](https://github.com/dhall-lang/dhall-lang)

```ucm
.> run .external.dhall.v1.testsuite.perfTest <path to local copy of github.com/dhall-lang/dhall-lang>
```
}}
testsuite.perfTest: '{IO, Exception} ()
testsuite.perfTest _ =
  args = !getArgs
  match List.head args with
    None -> printLine "Usage: run perfTest <path to local copy of https://github.com/dhall-lang/dhall-lang>"
    Some basePath ->
      startTime = !systemTimeMicroseconds
      path = FilePath.FilePath (basePath ++ "/tests/type-inference/success/preludeB.dhall")
      result = parseTestcase path
      duration = !systemTimeMicroseconds - startTime
      msg = match result with
        Left _ -> "Parse failure in " ++ (Int.toText duration) ++ "Î¼s"
        Right _ -> "Parsed successfully in " ++ (Int.toText duration) ++ "Î¼s"
      printLine msg

testsuite.importTest2 : Text -> Text -> Boolean
testsuite.importTest2 testDir name =
  use Text
  dirs = List.reverse (utils.splitOn "/" (testDir))
  use type_inference
  use .dhall.trunk.utils
  normalizedExpressionA = match parseTestcase (FilePath.FilePath (testDir ++ "/" ++ name ++ "A.dhall")) with
    Left err -> Debug.watch ("Parse error : " ++ err) None
    Right parsed ->
      match import.resolve (Path Here (File dirs (name ++ "A.dhall"))) parsed with
        Left msg -> Debug.watch ("Import error : " ++ msg) None
        Right resolved -> Optional.Some (betaNormalize resolved)

  normalizedExpressionB = match parseTestcase (FilePath.FilePath (testDir ++ "/" ++ name ++ "B.dhall")) with
    Left err -> Debug.watch ("Parse error : " ++ err) None
    Right parsed ->
      match import.resolve (Path Here (File dirs (name ++ "B.dhall"))) parsed with
        Left msg -> Debug.watch ("Import error : " ++ msg) None
        Right resolved -> Optional.Some (betaNormalize resolved)

  if normalizedExpressionA === normalizedExpressionB
    then true
    else
      printLine("Actual:\n" ++ (printOptional normalizedExpressionA))
      printLine("Correct:\n" ++ (printOptional normalizedExpressionB))
      false


testsuite.runTests : Text ->{IO, Exception} ()
testsuite.runTests path =
  origDirectory = !io.getCurrentDirectory
  withDefaultLoader : ('{RemoteLoader, EnvLoader, Cache, LocalLoader, g} b) -> {g, Exception, IO} b
  withDefaultLoader f =
    import.mapEnvironment Map.empty
      '(import.defaultFileLoader '(import.defaultHeaderRemoteLoader Map.empty
          '(import.withoutCache f)))

  bracket
    '(io.setCurrentDirectory (FilePath (path ++ "/..")))
    '(io.setCurrentDirectory origDirectory)
    '(match import.defaultHeaderRemoteLoader Map.empty with remoteLoader ->
        printTestStatus path (List.foldLeft updateResults (0,0) [
          -- runTestsRecursive  ("./dhall-lang/tests/parser/success") "A.dhall" parseSuccessTest,
          -- runTestsRecursive  ("./dhall-lang/tests/parser/failure") ".dhall" parseFailureTest,
          -- runTestsRecursive  ("./dhall-lang/tests/alpha-normalization") "A.dhall" alphaNormalizationTest,
          withDefaultLoader '(runTestsRecursive  ("./dhall-lang/tests/normalization") "A.dhall" normalizationTest),
          -- withDefaultLoader '(runTestsRecursive  ("./dhall-lang/tests/type-inference/success") "A.dhall" typeInferenceTest),
          -- runTestsRecursive  ("./dhall-lang/tests/type-inference/failure") ".dhall" typeInferenceFailureTest,
          -- import.mapEnvironment (Map.fromList [("DHALL_TEST_VAR", "6 * 7")]) '(
          --   import.defaultFileLoader '(
          --     remoteLoader '(
          --       (import.readOnlyCache (FilePath (path ++ "/tests/import/cache/dhall"))
          --         '(runTestsRecursive  ("./dhall-lang/tests/import/success") "A.dhall" importTest))))),
                -- '(runTestsRecursive  ("./dhall-lang/tests/import/success") "A.dhall" importTest) ())) ())' (),
          -- runTestsRecursive  ("./dhall-lang/tests/import/success") "A.dhallb" importTest2,
          -- withDefaultLoader '(runTestsRecursive  ("./dhall-lang/tests/semantic-hash/success") "A.dhall" semanticHashTest),
          -- runTestsRecursive  ("./dhall-lang/tests/binary-decode/success") "A.dhallb" binaryDecodeSuccessTest,
          -- runTestsRecursive  ("./dhall-lang/tests/binary-decode/failure") ".dhallb" binaryDecodeFailureTest,
        ]))
  ()


{{ {runTestSuite} will run the [Dhall acceptance tests](https://github.com/dhall-lang/dhall-lang/tree/master/tests)

Currently tests in the following categories are executed:

 - Parser test
 - Alpha normalization
 - Beta normalization

You need to specify the path to a local copy of [https://github.com/dhall-lang/dhall-lang](https://github.com/dhall-lang/dhall-lang) to run the command in ucm:

```ucm
.> run .external.dhall.v1.testsuite.runTestSuite <path to local copy of github.com/dhall-lang/dhall-lang>
```

}}
testsuite.runTestSuite: '()
testsuite.runTestSuite _ =
  args = !getArgs
  match List.head args with
    None -> printLine "Usage: run runTestSuite <path to local copy of https://github.com/dhall-lang/dhall-lang>"
    Some path -> runTests path |> '()

